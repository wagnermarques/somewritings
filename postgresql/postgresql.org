#+TITLE: PostgreSql Notes

* Apresentacao desse material  
  Cada um tem seu jeito de usar o postgres, tem aqui algumas maneiras
  de como eu utilizo.

* Instalando o postgresql
**  Os passos pra fazer a instalaÁ„o s„o:

  1) ObtenÁ„o e InstalaÁ„o dos bin·rios
     Em geral a gente usa o gerenciador de pacotes ou builda pelo
     codigo fonte. 
  2) Inicializar o diretÛrio de armazenamento initdb
  3) Configurar a porta e as interfaces que o serviÁo vai ouvir (postgresql.conf)
  4) Configurar as permissıes de acesso (arquivo pg_hba.conf)
  5) Iniciar o serviÁo
  6) Criar banco de teste
  7) Procedimentos de testes de conexıes conforme configurado em
     postgresql.conf e pg_hba.conf
       
** ObtenÁ„o e InstalaÁ„o dos bin·rios
   O mÈtodo mais pr·tico no linux È utilizar o gerenciador de pacotes

** Iniciar diretorio de armazenamento com initdb
   
** Configurar a porta e as interfaces de rede (postgresql.conf)

    Vc pode encontrar o seu postgresql.conf com o seguinte comando
    Vc vai perceber que ele se encontra no diretÛrio que vc
    inicializou com initdb

    #+NAME find postgresql.conf
    #+BEGIN_SRC sh :results output
    echo $ROOT_PASSWORD | sudo -S find / -name postgresql.conf
    #+END_SRC

    #+RESULTS:
    : 
    : postgresql.org#'   postgresql.org   script-sql.sql
 
   Encontre onde est· o seu postgresql.conf e troca a linha 
    listen_addresses = 'localhost'
    por
    listen_addresses = '*'
    e se a porta 5432 tiver comentada, pode descomentar e se o seu
    postgresql tiver em produÁ„o È bom mudar essa porta por seguranÁa.


** configurando o pg_hba.conf (HBA stands for host-based authentication) [ln:pgDocsHbaConf]  

   O local padr„o do pg_hba.conf È o diretÛrio de dados do pg. O
   diretÛrio de dados È chamado tecnicamente de "database cluster's
   data directory" pela documentaÁ„o do postgresql. 

   Se vc est· em uma m·quina em que n„o foi vc que instalou o
   postgresql e n„o sabe onde se encontra o arquivo pg_hba.conf, vc pode usar o
   comando find pra encontr·-lo.
   
   #+NAME sudo find / -name pg_hba.conf
   #+BEGIN_SRC sh
   echo $ROOT_PASSWORD | sudo -S find / -name pg_hba.conf
   #+END_SRC

   Esta È a saÌda do comando na minha m·quina.    
   #+RESULTS:
    | /var/lib/pgsql/11/data/pg_hba.conf                                                                                |
    | /home/wagner/wagnerdocri@gmail3/envs/env-dev/sources/Fedora-Dockerfiles/data-dir-for-postgresql/pgsql/pg_hba.conf |

   O conte˙do do arquivo È organizado em linhas e colunas, conforme
   exemplo da documentaÁ„o do postgresql.
   
   #+NAME exemplo pg_hba.conf
   #+BEGIN_SRC example
   local      database  user  auth-method  [auth-options] 
   host       database  user  address  auth-method  [auth-options]
   hostssl    database  user  address  auth-method  [auth-options]
   hostnossl  database  user  address  auth-method  [auth-options]
   host       database  user  IP-address  IP-mask  auth-method  [auth-options]
   hostssl    database  user  IP-address  IP-mask  auth-method  [auth-options]
   hostnossl  database  user  IP-address  IP-mask  auth-method  [auth-options]
   #+END_SRC
   
   *local* significa que ser· utilizado o socket para conex„o
   *host* significa que ser· utilizado tpc/ip pra conex„o
   *hostssl* - tcp/ip com ssl
   *hostnossl* - tcp/ip sem ssl   
   *database,user,address,IP-address,Ip-maks* j· pra sacar o que È nÈ?    
   *auth-method*[ln:pgDocsAuthMethods] È o mÈtodo de autenticaÁ„o
    *peer* sÛ pra conexıes locais. Obtem o usu·rio do prÛprio sistema operacional.
    *trust* significa que n„o precisa de nenhum mÈtodo de autenticaÁ„o
    *reject* significa rejeitado independente do mÈtodo de autenticaÁ„o
    *scram-sha-256* usa o mÈtodo SCRAM-SHA-256 pra verificar usu·rio e senha
    *md5* usa o mÈtodo SCRAM-SHA-256
    *password* Senha n„o criptografada
    *gss* usa GSSAPI[ln:wikiGSSAPI] pra autenticar o usu·rio
    *sspi* usa SSPI[ln:wikiSSPI] pra autenticar o usu·rio. SÛ faz sentido no windows
    *ident* O postgres vai perguntar pra um servidor de identididade
   no mesmo ip que est· tentando se conectar nele. No linux È comum um
   desses ouvindo na porta 113. Ent„o pra usar ident vc precisa disso.
    *ldap* Servidor ldap
    *radius* usa radios pra verificar usuario e senha
    *cert* usa certificado ssl do cliente
    *pam* usa Pluggable Authentication Modules (PAM) do linux
    *bsd* usa sistema de autenticaÁ„o do BSD

    O arquivo padr„o, criado automaticamente no processo de instalaÁ„o
    È mais ou menos assim...
    #+NAME pg_hba.conf padrao
    #+BEGIN_SRC example 
    # TYPE  DATABASE        USER            ADDRESS                 METHOD
    # "local" is for Unix domain socket connections only
    local   all             all                                     peer
    # IPv4 local connections:
    host    all             all             127.0.0.1/32            ident
    # IPv6 local connections:
    host    all             all             ::1/128                 ident
    # Allow replication connections from localhost, by a user with the
    # replication privilege.
    local   replication     all                                     peer
    host    replication     all             127.0.0.1/32            ident
    host    replication     all             ::1/128                 ident                                                                       
    #+END_SRC
   
   Uma configuraÁ„o que uso sÛ pra programar È o seguinte...
   #+NAME
   #+BEGIN_SRC 
   host    all             all              0.0.0.0/0                       md5
   host    all             all             ::1/128                          md5
   #+END_SRC

   Siginifica que com a conex„o tcp/ip habilitada eu consigo conectar
   usando ipv4 e informando o usuario e senha configurada no prÛprio postgresql.
   
*** configurar acesso via tcp
    https://blog.bigbinary.com/2016/01/23/configure-postgresql-to-allow-remote-connection.html

** Configurar permissıes de acesso

** Iniciar o serviÁo
   Tem v·rias maneiras de inicializar o postgresql. 
   No momento, na minha m·quina, como uso systemd, uso o seguinte
   comando
   sudo systemctl start postgresql-11.service
   sudo systemctl status postgresql-11.service
   #+NAME sudo systemctl start postgresql
   #+BEGIN_SRC sh :results output
   echo $ROOT_PASSWORD | sudo -S systemctl start postgresql-11.service
   echo $ROOT_PASSWORD | sudo -S systemctl status postgresql-11.service
   #+END_SRC

   #+RESULTS:
   #+begin_example
   ‚óè postgresql-11.service - PostgreSQL 11 database server
      Loaded: loaded (/usr/lib/systemd/system/postgresql-11.service; disabled; vendor preset: disabled)
      Active: active (running) since Sun 2019-01-06 01:05:33 -02; 7s ago
        Docs: https://www.postgresql.org/docs/11/static/
     Process: 5844 ExecStartPre=/usr/pgsql-11/bin/postgresql-11-check-db-dir ${PGDATA} (code=exited, status=0/SUCCESS)
    Main PID: 5849 (postmaster)
       Tasks: 8 (limit: 4394)
      Memory: 19.0M
      CGroup: /system.slice/postgresql-11.service
              ‚îú‚îÄ5849 /usr/pgsql-11/bin/postmaster -D /var/lib/pgsql/11/data/
              ‚îú‚îÄ5850 postgres: logger   
              ‚îú‚îÄ5852 postgres: checkpointer   
              ‚îú‚îÄ5853 postgres: background writer   
              ‚îú‚îÄ5854 postgres: walwriter   
              ‚îú‚îÄ5855 postgres: autovacuum launcher   
              ‚îú‚îÄ5856 postgres: stats collector   
              ‚îî‚îÄ5857 postgres: logical replication launcher   

   jan 06 01:05:31 Unknown systemd[1]: Stopped PostgreSQL 11 database server.
   jan 06 01:05:31 Unknown systemd[1]: Starting PostgreSQL 11 database server...
   jan 06 01:05:32 Unknown postmaster[5849]: 2019-01-06 01:05:32.414 -02 [5849] LOG:  listening on IPv6 address "::1", port 5432
   jan 06 01:05:32 Unknown postmaster[5849]: 2019-01-06 01:05:32.414 -02 [5849] LOG:  listening on IPv4 address "127.0.0.1", port 5432
   jan 06 01:05:32 Unknown postmaster[5849]: 2019-01-06 01:05:32.512 -02 [5849] LOG:  listening on Unix socket "/var/run/postgresql/.s.PGSQL.5432"
   jan 06 01:05:32 Unknown postmaster[5849]: 2019-01-06 01:05:32.706 -02 [5849] LOG:  listening on Unix socket "/tmp/.s.PGSQL.5432"
   jan 06 01:05:32 Unknown postmaster[5849]: 2019-01-06 01:05:32.991 -02 [5849] LOG:  redirecting log output to logging collector process
   jan 06 01:05:32 Unknown postmaster[5849]: 2019-01-06 01:05:32.991 -02 [5849] HINT:  Future log output will appear in directory "log".
   jan 06 01:05:33 Unknown systemd[1]: Started PostgreSQL 11 database server.
   #+end_example

** mudar a senha do usu·rio postgres
   sudo passwd postgres
   (informe a nova senha)
   su postgres
   psql
   \password postgresql
   (informe a nova senha)
   
** criar um banco de teste
   


** Criar banco de teste
   

** Testes de acesso
   su -u postgres psql



* Usando o postgresql
** comandos do tipo \X
   postgres=# \c nome_do_banco

** Listar databases
 postgres=# \l
                                        List of databases
          Name         |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges   
 ----------------------+----------+----------+-------------+-------------+-----------------------
  novo_sus_development | postgres | UTF8     | pt_BR.UTF-8 | pt_BR.UTF-8 | 
  novo_sus_test        | postgres | UTF8     | pt_BR.UTF-8 | pt_BR.UTF-8 | 
  postgres             | postgres | UTF8     | pt_BR.UTF-8 | pt_BR.UTF-8 | 
  template0            | postgres | UTF8     | pt_BR.UTF-8 | pt_BR.UTF-8 | =c/postgres          +
                       |          |          |             |             | postgres=CTc/postgres
  template1            | postgres | UTF8     | pt_BR.UTF-8 | pt_BR.UTF-8 | =c/postgres          +
                       |          |          |             |             | postgres=CTc/postgres
 (5 rows)


 O comando \l+ mostra um pouco mais de informaÁıes
 postgres=# \l+
                                                                          List of databases
          Name         |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges   |  Size   | Tablespace |                Description   
              
 ----------------------+----------+----------+-------------+-------------+-----------------------+---------+------------+------------------------------
 --------------
  novo_sus_development | postgres | UTF8     | pt_BR.UTF-8 | pt_BR.UTF-8 |                       | 7653 kB | pg_default | 
  novo_sus_test        | postgres | UTF8     | pt_BR.UTF-8 | pt_BR.UTF-8 |                       | 7521 kB | pg_default | 
  postgres             | postgres | UTF8     | pt_BR.UTF-8 | pt_BR.UTF-8 |                       | 7653 kB | pg_default | default administrative connec
 tion database
  template0            | postgres | UTF8     | pt_BR.UTF-8 | pt_BR.UTF-8 | =c/postgres          +| 7521 kB | pg_default | unmodifiable empty database
                       |          |          |             |             | postgres=CTc/postgres |         |            | 
  template1            | postgres | UTF8     | pt_BR.UTF-8 | pt_BR.UTF-8 | =c/postgres          +| 7521 kB | pg_default | default template for new data
 bases
                       |          |          |             |             | postgres=CTc/postgres |         |            | 
 (5 rows)

 postgres=# 

** listar roles
 postgres=# \du
                                    List of roles
  Role name |                         Attributes                         | Member of 
 -----------+------------------------------------------------------------+-----------
  postgres  | Superuser, Create role, Create DB, Replication, Bypass RLS | {}

 postgres=# 




  
* Habilitar conexao remota via tcp
  Pra habilitar conexao via qualquer outra host via tcpip
  entrar em  postgresql.conf e mudar para listen_addresses = '*' 
  entrar em pg_hba.conf e edicionar...
  host    all             all              0.0.0.0/0                       md5
  host    all             all              ::/0                            md5


* psql: exemplos
** opcao -c pra enviar comandos
   #+NAME:setup                   
   #+BEGIN_SRC shell :session s1 :results output :exports both
      export host=45.79.225.175
      export user=postgres
   #+END_SRC

   #+RESULTS: setup

  
   #+NAME: psql -c '\x' -c 'SELECT * FROM foo;'
   #+BEGIN_SRC shell :session s1 :results output :exports both
    psql -h $host -U $user -c "drop database dbteste"
    psql -h $host -U $user -c '\x' -c 'create database dbteste'
   #+END_SRC

   #+RESULTS: psql -c '\x' -c 'SELECT * FROM foo;'
   : DROP DATABASE
   : Exibi√É¬ß√É¬£o expandida est√É¬° habilitada.
   : CREATE DATABASE

** opcao -f pra passar um arquivo sql pra execucao
   

   Considere o arquivo script-sql.sql com o seguinte conteudo

   #+INCLUDE: ./script-sql.sql :src sql

   
   #+NAME: psql -h $host -U $user -f script-sql.sql
   #+BEGIN_SRC shell :session s1 :results output :exports both
      psql -h $host -U $user -f script-sql.sql
      psql -h $host -U $user -d testdb -c "select * from clientes"
   #+END_SRC

   #+RESULTS: psql -h $host -U $user -f script-sql.sql
   #+begin_example
   psql:script-sql.sql:1: ERROR:  syntax error at or near "dropt"
   LINHA 1: dropt database testdb;
            ^
   CREATE DATABASE
   psql (11.6, servidor 12.1 (Debian 12.1-1.pgdg100+1))
   AVISO: psql vers√É¬£o 11, servidor vers√É¬£o 12.
            Algumas funcionalidades do psql podem n√É¬£o funcionar.
   Voc√É¬™ est√É¬° conectado agora ao banco de dados "testdb" como usu√É¬°rio "postgres".
   CREATE TABLE
   INSERT 0 4
   nome    | tipodecliente |      emaildocliente      
   -----------+---------------+--------------------------
    Huguinho  | vip           | wagnerdocri@gmail.com
    Zezinho   |               | 
    Luizinho  | vip           | wagnermarques@usp.br
    Luluzinha | vip           | denise.candria@gmail.com
   (4 registros)
   #+end_example

   #+RESULTS: psql -h $host -U $user
   : total 52
   : postgresql.org#'
   : -rwxrwxr-x. 1 wagner wagner 21115 jan 18 10:39  postgresql.org
   : -rw-rw-r--  1 wagner wagner   467 jan 18 10:39  script-sql.sql

* links
** documentacao e tutoriais
   https://www.postgresql.org/docs/12/index.html

** cheat sheets
  https://www.cheatography.com//squixy/cheat-sheets/postgresql-interactive-terminal-commands/pdf/


* info
pgsql -a 
  -a
       --echo-all
           Print all nonempty input lines to standard output as they are read. (This does not apply to lines read interactively.) This is equivalent to setting
           the variable ECHO to all.

 -c command
       --command=command
           Specifies that psql is to execute the given command string, command. This option can be repeated and combined in any order with the -f option. When
           either -c or -f is specified, psql does not read commands from standard input; instead it terminates after processing all the -c and -f options in
           sequence.

           command must be either a command string that is completely parsable by the server (i.e., it contains no psql-specific features), or a single backslash
           command. Thus you cannot mix SQL and psql meta-commands within a -c option. To achieve that, you could use repeated -c options or pipe the string into
           psql, for example:

               psql -c '\x' -c 'SELECT * FROM foo;'

           or

               echo '\x \\ SELECT * FROM foo;' | psql

           (\\ is the separator meta-command.)

           Each SQL command string passed to -c is sent to the server as a single request. Because of this, the server executes it as a single transaction even if
           the string contains multiple SQL commands, unless there are explicit BEGIN/COMMIT commands included in the string to divide it into multiple
           transactions. (See Section 53.2.2.1 for more details about how the server handles multi-query strings.) Also, psql only prints the result of the last
           SQL command in the string. This is different from the behavior when the same string is read from a file or fed to psql's standard input, because then
           psql sends each SQL command separately.

           Because of this behavior, putting more than one SQL command in a single -c string often has unexpected results. It's better to use repeated -c commands
           or feed multiple commands to psql's standard input, either using echo as illustrated above, or via a shell here-document, for example:

               psql <<EOF
               \x
               SELECT * FROM foo;
               EOF

 -d dbname
       --dbname=dbname
           Specifies the name of the database to connect to. This is equivalent to specifying dbname as the first non-option argument on the command line.

           If this parameter contains an = sign or starts with a valid URI prefix (postgresql:// or postgres://), it is treated as a conninfo string. See
           Section 34.1.1 for more information.

       -e
       --echo-queries
           Copy all SQL commands sent to the server to standard output as well. This is equivalent to setting the variable ECHO to queries.


 -f filename
       --file=filename
           Read commands from the file filename, rather than standard input. This option can be repeated and combined in any order with the -c option. When either
           -c or -f is specified, psql does not read commands from standard input; instead it terminates after processing all the -c and -f options in sequence.
           Except for that, this option is largely equivalent to the meta-command \i.

           If filename is - (hyphen), then standard input is read until an EOF indication or \q meta-command. This can be used to intersperse interactive input
           with input from files. Note however that Readline is not used in this case (much as if -n had been specified).

           Using this option is subtly different from writing psql < filename. In general, both will do what you expect, but using -f enables some nice features
           such as error messages with line numbers. There is also a slight chance that using this option will reduce the start-up overhead. On the other hand,
           the variant using the shell's input redirection is (in theory) guaranteed to yield exactly the same output you would have received had you entered
           everything by hand.

  -F separator
       --field-separator=separator
           Use separator as the field separator for unaligned output. This is equivalent to \pset fieldsep or \f.

 -l
       --list
           List all available databases, then exit. Other non-connection options are ignored. This is similar to the meta-command \list.

           When this option is used, psql will connect to the database postgres, unless a different database is named on the command line (option -d or non-option
           argument, possibly via a service entry, but not via an environment variable).

       -L filename
       --log-file=filename
           Write all query output into file filename, in addition to the normal output destination.
  -o filename
       --output=filename
           Put all query output into file filename. This is equivalent to the command \o.

       -p port
       --port=port
           Specifies the TCP port or the local Unix-domain socket file extension on which the server is listening for connections. Defaults to the value of the
           PGPORT environment variable or, if not set, to the port specified at compile time, usually 5432.


  -v assignment
       --set=assignment
       --variable=assignment
           Perform a variable assignment, like the \set meta-command. Note that you must separate name and value, if any, by an equal sign on the command line. To
           unset a variable, leave off the equal sign. To set a variable with an empty value, use the equal sign but leave off the value. These assignments are
           done during command line processing, so variables that reflect connection state will get overwritten later.


   -V
       --version
           Print the psql version and exit.

       -w
       --no-password
           Never issue a password prompt. If the server requires password authentication and a password is not available by other means such as a .pgpass file,
           the connection attempt will fail. This option can be useful in batch jobs and scripts where no user is present to enter a password.
  -W
       --password
           Force psql to prompt for a password before connecting to a database.

           This option is never essential, since psql will automatically prompt for a password if the server demands password authentication. However, psql will
           waste a connection attempt finding out that the server wants a password. In some cases it is worth typing -W to avoid the extra connection attempt.

           Note that this option will remain set for the entire session, and so it affects uses of the meta-command \connect as well as the initial connection
           attempt.

-1
       --single-transaction
           This option can only be used in combination with one or more -c and/or -f options. It causes psql to issue a BEGIN command before the first such option
           and a COMMIT command after the last one, thereby wrapping all the commands into a single transaction. This ensures that either all the commands
           complete successfully, or no changes are applied.

           If the commands themselves contain BEGIN, COMMIT, or ROLLBACK, this option will not have the desired effects. Also, if an individual command cannot be
           executed inside a transaction block, specifying this option will cause the whole transaction to fail.




* usando elephantsql
  
  #+NAME
  #+BEGIN_SRC sh
    curl -u :xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxxx  https://api.elephantsql.com/api/backup?db=my-db
  #+END_SRC
 

* Refs
[ln:pgInstFedCent]  https://www.if-not-true-then-false.com/2012/install-postgresql-on-fedora-centos-red-hat-rhel/
[ln:pgDocsHbaConf] https://www.postgresql.org/docs/10/auth-pg-hba-conf.html
[ln:wikiGSSAPI] https://en.wikipedia.org/wiki/Generic_Security_Services_Application_Program_Interface
[ln:wikiSSPI] https://en.wikipedia.org/wiki/Security_Support_Provider_Interface
[ln:pgDocsAuthMethods] https://www.postgresql.org/docs/10/auth-methods.html


