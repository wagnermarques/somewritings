#+Title: Emacs org-mode
* Apresentação
  Sobre o org-mode... 
* Date e Time
** Inserindo uma data (timestamp) no documento
   C-c ! (org-time-stamp-inactive) Insere um timestamp que nao gera uma
   entrada na agenda do org-mode
   [2017-01-18 Qua]

** Inserindo uma data do calendário
   C-c <
   <2017-01-19 Qui>

** Timer
    + C-c C-x . [Inicia timer]
    + C-c C-x . [de novo pra inserir vlr do timer] pode fazer isso várias vezes
    + C-c C-x - [Depois que já usou o timer, isso o desliga]
   
* Navegacao
   C-c p (Navega pra sessão anterior)
   C-c n (Navega pra próxima sessão)
** Abrindo e Fechando sessoes do documento
    O mais comum é alternar abrir e fechar com tab
    As vezes a sessão está extensa, com muitos parágrafos, códigos
    etc... Você quer fechar a sessão mas com tab não dá porque você
    teria que ir até o início da sessão pra poder posicionar o cursos
    pra então dar o tab e fechar a a sessão do dumento. Você queria
    fechar a sessão do documento de qualquer parte que o curso estiver
    dentreo dela... é fácil S-<tab>

* Links
** Links Externos
   C-c C-l
   Aparecerá pra você o seguinte...

   Insert a link.
   Use TAB to complete link prefixes, then RET for type-specific completion support

   O seu cursor estará no minibuffer...
   Pode dar um TAB 
   Depois disso o emacs abre outro buffer pra vc conforme abaixo

   Click on a completion to select it.
   In this buffer, type RET to select the completion near point.

   Possible completions are:
   bbdb: 	bibtex: 	docview: 	doi: 	elisp: 	file+emacs:
   file+sys: 	file: 	ftp: 	gnus: 	help: 	http:
   https: 	info: 	irc: 	mailto: 	message: 	mhe:
   news: 	rmail: 	shell:     
   
   Você pode clicar em http, por exemplo...
   Então o minibuffer te pergunta a url, eu coloquei www.google.com
   Após vc digiar a url e dar um enter
   O minibuffer pergunta a descrição do link, eu coloquei: site do google
   Após o Enter, o resultado segue abaixo
   [[http:www.google.com][site do google]]
   Um clike simples do mouse abre o link no navegador.

* Propriedades
** global
   no inicio do documento da pra colocar uma propriedade global que vai
   valer, por exemplo, para todos os blocos de codigos...

  #+PROPERTY: HEADER-ARGS :dir ~/org/tmp

  :dir vai valer como header arg pra todos os blocos

  Tambem da pra subscrever essas propos nas sessoes com 

  https://emacs.stackexchange.com/questions/27179/orgmode-set-global-babel-parameters

  #+EXAMPLE
  :PROPERTIES:
  :header-args: :session *R* :cache yes :results output graphics :exports both :tangle yes
  :END:
  #+END_EXAMPLE

* LATEX
** LATEX BLOCKS
   https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-LaTeX.html
   #+begin_export latex
   
   #+end_export
** LATEX_HEADER
#+begin_example

#+end_example

* Babel (Block Code Vars)
** Introduçao
** pre requisitos
   Você tem que colocar no seu arq de conf do emacs quais as
   linguagens você vai utilizar nos seus blocos de códigos. Você faz
   isso conforme bloco de código abaixo.
   http://orgmode.org/worg/org-contrib/babel/languages.html

#+BEGIN_SRC emacs-lisp
;;;;http://orgmode.org/guide/Working-With-Source-Code.html
;;;;http://orgmode.org/worg/org-contrib/babel/languages/ob-doc-lisp.html
;;(require 'ess-site) ;;for R
(require 'ob-sh)
(org-babel-do-load-languages
 'org-babel-load-languages
 '(
   (shell . t) ;;http://thread.gmane.org/gmane.emacs.orgmode/102877
   (python . t)
   (R . t)
   (ruby . t)
   (ditaa . t)
   (dot . t)
   (octave . t)
   (sqlite . t)
   (perl . t)
   (emacs-lisp . t)
   ))
#+END_SRC

#+RESULTS:
: 
: sh-4.3$ sh-4.3$ asdf

** Trabalhando com codigo
   http://orgmode.org/manual/Working-With-Source-Code.html
*** O padrãozão pra inserir um bloco de código é...
   #+NAME: <NOME_DO_BLOCO_DE_CODIGO>
   #+BEGIN_SRC <LINGUAGEM_DO_BLOCO> <OPCOES> <PROPRIEDADES DE HEADER DO BLOCO>
    CODIGO NA LINGUAGEM ESPECIFICADA
   #+END_SRC
   
*** Atalhos para inserção de blocos de código
   https://emacs.stackexchange.com/questions/12841/quickly-insert-source-blocks-in-org-mode
   Digite "<s" sem as aspas e dê um ENTER
   Tem mais sobre isso em:
   http://orgmode.org/manual/Easy-Templates.html
*** pra customizar você pode colocar isso no seu arq de conf do emacs

#+NAME: org-structure-template-alist to config <s
#+BEGIN_SRC emacs-lisp 
        (add-to-list 'org-structure-template-alist
                     '("s" "#+NAME: <code_blk_name>
  ,#+HEADER: :session <session_name>
  ,#+HEADER: :var data1=1 :var data2=2 :var data3=3\n
  ,#+HEADER: :results value<value|output>  scalar<table|vector|list|scalar|verbatim|file>  org<raw|org|html|latex|pp|drawer> replace<silent|replace|append|prepend>\n
  ,#+BEGIN_SRC <lang>\n\n#+END_SRC"))
#+END_SRC

#+RESULTS: org-structure-template-alist to config <s
| s | #+NAME: <code_blk_name> |

*** compartilhar variavies entre os blocos
    https://orgmode.org/manual/var.html
    














*** bloco de codigo a partir de um arquivo externo

    Se quizer se aprofundar mais sobre isso: http://orgmode.org/manual/Property-syntax.html#Property-syntax
*** header arguments
    http://orgmode.org/manual/Header-arguments.html#Header-arguments
    http://orgmode.org/manual/Code-block-specific-header-arguments.html#Code-block-specific-header-arguments
    http://orgmode.org/manual/Specific-header-arguments.html#Specific-header-arguments
**** Code block specific header arguments
1. Os argumentos de header do seu bloco de código pode ser in line
   ou em multiplas linhas com a palavra chave header
+ In line:
  BEGIN_SRC haskell :results silent :exports code :var n=0
+ Multiplas linhas
  HEADER: :var data1=1
  BEGIN_SRC emacs-lisp :var data2=2
***** argumento de header "result" formatando o resultado
      http://orgmode.org/manual/results.html
      + Forma de coletar o resultado (Collect)
        ":results value"
        Obtem o retorno do seu codigo. Algumas linguagem precisa da
        instrução "return".

        ":results output"
        Coleta o resultado do código assim como ele apareceria na
        saída pradrão
      + Tipo de saída
        *table, vector* interpreta a saída do código pelo próprio
        org-table. Portanto, se o resultado for um único valor cria-se
        uma tabela com uma linha e uma coluna pra exibir o resultado.
        "Exemplo típico seria :results value table."
        *list* Faz com que o resultado seja interpretado como um lista
        do org-mode. Havendo um resultado, obtém-se uma lista com um item.
        *scalar, verbatim* O resultado obtido literalmente. "Exemplo
        típico seria :results value verbatim."
        *file* Neste caso o org-mode interpreta o caminho do arquivo
        gerado inserindo um link pra ele no arquivo em que o bloco de
        código rodou. "Exemplo tipico  :results value file. "
      + Format da saída
        *raw*
        Como o nome diz, é interpretado como raw (fix-me: melhor
        traduçao pra raw)
        É inserido diretamente no buffer a alinhado se for uma tabela
        "Exemplo típico seria :results value raw
        *org* 
        O resultado é inserido num bloco de código do tipo org.
        "Exemplo típico seria  :results value org"
        *html*
        Resultado é inserido num block  BEGIN_EXPORT html block. 
        "Exemplo  :results value html"
        *latex* 
        Resultado é inserido num bloco do tipo  BEGIN_EXPORT latex
        block. 
        Exemplo  :results value latex
        *code* 
        Resultado é inserido num blocl de códig mesmo. Isso é útil
        quando a saída pode ser executada ou deve ser parseada.
        Exemplo  :results value code."
        *pp*
        Resultado é convertido para "pretty-print source code".
        Ou seja, é inserido num  'src' code block. 
        As linguagem suportadas são: Emacs Lisp, Python, and Ruby. 
        Exemplo: :results value pp.
        *drawer*
        Resulta é encapsulado num RESULTS drawer. 
        ùtil quando o resultado contém  raw or org results próprio
        para um reprocessamento automático.
        Exemplo :results value drawer. 
      + Handling
        *silent*
        Ignora o resultado e não insere no buffer do código
        executado. Expoe a saída no mini buffer apenas.
        Exemplo  :results output silent.
        *replace* 
        É o padrão. Substitui a execuçãoo anterior pela mais recente.
        Exemplo :results output replace.
        *append* 
        Acrescenta no buffer sem excluir o resultado da execução
        anterior. Os resultados anteriores vão ficando em baixo.
        Exemplo  :results output append.
        *prepend*
        Mesmo que append, mas acrescenta novos resultado no final dos
        restulados anteriores.

**** Processando os resultados dos blocos de código
     http://orgmode.org/manual/Results-of-evaluation.html



#+NAME: safd
#+HEADER: :session <session_name>
#+HEADER: :var data1=1 :var data2=2 :var data3=3
#+HEADER: :results <value|output> < 
#+BEGIN_SRC sh
echo "$data2"
#+END_SRC

#+RESULTS: safd
|                   |
| sh-4.3$ sh-4.3$ 2 |



**** Passando variaveis pra dentro do seu codigo
     
#+NAME: teste111
#+HEADER: :session *session_name_here*:
#+HEADER: :var data1=1 :var data2=2
#+BEGIN_SRC sh
echo "Valor de data1: $data1"
echo "Valor de data2: $data2 "
#+END_SRC

#+RESULTS: teste111
|         |       |        |        |   |
| sh-4.3$ | Valor | de     | data1: | 1 |
| Valor   | de    | data2: |      2 |   |

*** include files
    Codigo provindos de um arquivo de codigo
    #+INCLUDE: "~/.emacs" src emacs-lisp
    http://orgmode.org/manual/Include-files.html

*** rodando comandos do shell
  
   begin_src sh
   #+name obter usuario com id
   #+begin_src sh
   id
   #+end_src

   #+RESULTS:
   | uid=1000(wagner) gid=1000(wagner) grupos=1000(wagner) | 10(wheel) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 |
  

   begin_src sh :dir /sudo::
   #+name obter usuario com id e propriedade :dir /sudo
   #+begin_src sh :dir /sudo::
   id
   #+end_src

   #+RESULTS:
   : uid=0(root) gid=0(root) groups=0(root) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023

   Isso significa que você é root nesse comando, o emacs, a primeira
   vez que você roda o comando, vai pedir a senha do root, mas depois
   ele usa a senha que vc já forneceu nas vezes subsequentes.
   
  

*** propriedades do bloco de código
    linguagem: sh ou emacs-lisp etc
    :eval never-exports  
    :results output replace  
    :exports both
BEGIN_SRC emacs-lisp  :eval never-exports :output output :export both

Propriedade :output
O valor "replace" (:output replace é o padrão), então não precisa
colocar se não quizer.
O valor "output" significa...
   
*** Sintaxe Highlight
 #+name: codigo_em_emacs-lisp
 #+BEGIN_SRC emacs-lisp  :eval never-exports :output output :export both
 ;; fontify code in code blocks
 (message "mensagem5")
 #+END_SRC    

 #+RESULTS: codigo_em_emacs-lisp
 : mensagem5

*** Sintaxe highlight na exportação
    https://github.com/syl20bnr/spacemacs/issues/7055
*** Refs
    http://stackoverflow.com/questions/20309842/how-to-syntax-highlight-for-org-mode-inline-source-code-src-lang
    http://orgmode.org/worg/org-contrib/babel/examples/fontify-src-code-blocks.html

*** Usando variáveis em Blocos de Códigos ShellScript
*** Argumentos especificos para Head Code Block
    http://orgmode.org/manual/Code-block-specific-header-arguments.html
**** System-wide header arguments: Set globally, language-specific 
     http://orgmode.org/manual/System_002dwide-header-arguments.html#System_002dwide-header-arguments
     Existe uma variável global do emacs com nome:
     org-babel-default-header-args
     Esta variável define valores padrão para propriedades de head de
     um bloco de código do babel. 
     Os valores padrões são:
     :session    => "none"
     :results    => "replace"
     :exports    => "code"
     :cache      => "no"
     :noweb      => "no"
     Alterando essa variavel global você pode modificar esses valores
     padrões no seu emacs.

    #+name: var abobe BEGIN_SRC sh works
    #+var: Path=(format "'%s%s'" (file-name-directory (buffer-file-name)) "")
    #+BEGIN_SRC sh :eval never-exports  :results output replace  :exports both
    echo $Path #If var were in line with BEGIN_SRC line would work, but above dont
    ls -l $($Path) #YES works
    #+END_SRC

    #+RESULTS:
    : 
    : total 8
    : -rw-rw-r--. 1 wagner wagner  183 Jan  6 00:21 1
    : -rw-rw-r--. 1 wagner wagner 1464 Jan  6 00:34 emacs-org-mode.org


    #+name: var inline with BEGING_SRC sh
    #+BEGIN_SRC sh :eval never-exports :var Path=(format "'%s%s'" (file-name-directory (buffer-file-name)) "") :results output replace  :exports both
    echo $Path #YES PRINT $Path variable value
    ls -l $($Path) #YES list files in $Path 
    #+END_SRC

    #+RESULTS: var inline with BEGING_SRC sh
    : '/run/media/wagner/96fea5f1-d297-4f63-a035-abf6511467be/wagnerdocri@gmail.com2/envs/somewritings/emacs-org-mode/'
    : total 8
    : -rw-rw-r--. 1 wagner wagner  183 Jan  6 00:21 1
    : -rw-rw-r--. 1 wagner wagner 1471 Jan  6 00:35 emacs-org-mode.org




    #+name: Must use $($Path) because $Path does not works
    #+BEGIN_SRC sh :eval never-exports :var Path=(format "'%s%s'" (file-name-directory (buffer-file-name)) "") :results output replace  :exports both
    echo $Path #YES PRINT $Path variable value
    ls -l $Path 2>&1 #inhibit all possible output
    #+END_SRC

    #+RESULTS: Must use $($Path) because $Path does not works


    Still not can change dir to $Path neither $($Path) but ls $($Path) works
    #+name: Changing dir to var  Path value
    #+BEGIN_SRC sh :eval never-exports :var Path=(format "'%s%s'" (file-name-directory (buffer-file-name)) "") :results output replace  :exports both
    echo $Path #YES PRINT $Path variable value

    cd  $Path 2>&1 #does not works as showed below

    cd $($Path) 2>&1 #does not work as showed below
    echo [1] -$(pwd) # print user home directory

    p=$Path
    cd $p 2>&1 #does not work as showed below
    echo [2] -$(pwd) # print user home directory

    p=$($Path) 
    cd $p 2>&1 #does not work as showed below 
    echo [3] -$(pwd) # print user home directory

    p="$($Path)" 
    cd $p 2>&1 #does not work as showed below 
    echo [4] -$(pwd) # print user home directory

    p="$($Path)" 
    cd "$($Path)" #does not work as showed below 
    echo [5] -$(pwd) # print user home directory

    export p=$Path 
    cd $p #does not work as showed below 
    echo [6] -$(pwd) # print user home directory


    #+END_SRC

    #+RESULTS: Changing dir to var  Path value
    : '/run/media/wagner/96fea5f1-d297-4f63-a035-abf6511467be/wagnerdocri@gmail.com2/envs/somewritings/emacs-org-mode/'
    : sh: line 7: cd: '/run/media/wagner/96fea5f1-d297-4f63-a035-abf6511467be/wagnerdocri@gmail.com2/envs/somewritings/emacs-org-mode/': Arquivo ou diretÃ³rio nÃ£o encontrado
    : [1] -/home/wagner
    : sh: line 13: cd: '/run/media/wagner/96fea5f1-d297-4f63-a035-abf6511467be/wagnerdocri@gmail.com2/envs/somewritings/emacs-org-mode/': Arquivo ou diretÃ³rio nÃ£o encontrado
    : [2] -/home/wagner
    : [3] -/home/wagner
    : [4] -/home/wagner
    : [5] -/home/wagner
    : [6] -/home/wagner













**** Language-specific header arguments
     http://orgmode.org/manual/Language_002dspecific-header-arguments.html#Language_002dspecific-header-arguments
     Cada linguagem pode ter suas proprias propriedades e seus
     respectivos valores padrão.
     Para configurar isso basta customizar a variável global
     *org-babel-default-header-args:<lang>*
     "<lang>" você diz qual é o nome da linguagem
     Mais detalhes em http://orgmode.org/worg/org-contrib/babel.      
     Demostrações...
**** Header arguments in Org mode properties
     http://orgmode.org/manual/Header-arguments-in-Org-mode-properties.html#Header-arguments-in-Org-mode-properties

     Exemplo:
     #+PROPERTY: header-args:sh  :session *sh*
     #+PROPERTY: header-args    :results silent
     #+Name: ls exemplificando sesson e result silent
     #+Beging_src sh
     ls -il
     #+End_src
     
     #+BEGIN_SRC 
     
     #+END_SRC
     
     
** exportar
*** :exports
    :exports code
    :exports both
    :exports none


* foootnotes
[fn:[fn:External-links] https://orgmode.org/manual/External-links.html
[fn:External-links][[ http://www.astro.uva.nl/~dominik ]

   
