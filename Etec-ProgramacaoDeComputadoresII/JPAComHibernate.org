#+Title: Configurando JPA com Hibernate

* O que é JPA e Hibernate
  A gente viu isso na aula teórica... :))


* Passo a passo pra usar JPA com Hibernate
  Primeiro, você precisa do hibernate propriamente dito
  Ou vc faz o donwload na mão ou simplesmente coloca as seguintes
  dependencia no seu pom.xml

  Por favor, nao vai esquecer que tem que ser dentro da tag 'dependecies'

  #+BEGIN_SRC xml
    <!-- JPA 2.1 COM Hibernate 5 -->
    <!-- Hibernate -->
    <!-- Hibernate Core -->
    <!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-core -->
    <dependency>
      <groupId>org.hibernate</groupId>
      <artifactId>hibernate-core</artifactId>
      <version>${version.hibernate}</version>
    </dependency>

    <dependency>
      <groupId>org.hibernate</groupId>
      <artifactId>hibernate-entitymanager</artifactId>
      <version>${version.hibernate}</version>
      <scope>runtime</scope>
    </dependency>                

    <dependency>
      <groupId>org.hibernate.javax.persistence</groupId>
      <artifactId>hibernate-jpa-2.1-api</artifactId>
      <version>${version.hibernate-jpa-2.1-api}</version>
    </dependency>
    
    <!-- c3p0 -->
    <dependency>
      <groupId>com.mchange</groupId>
      <artifactId>c3p0</artifactId>
      <version>0.9.5.2</version>
    </dependency>  
  #+END_SRC

  Lembrando que precisamos fornecer o valor para a versão do
  hibernate-entitymanager e do hibernate-core porque o que term de
  informação é uma sintaxe do maven pra coleta-las como uma tag da
  sessao properties do pom indicada respectivamente por
  ${version.hibernate} e ${version.hibernate-jpa-2.1-api}

  Essa sintaxe está dizendo que o maven vai procurar o valor da versão
  respectivamente na tab <version.hibernate> e
  <version.hibernate-jpa-2.1-api> que estejam dentro da sessão
  properties do seu pom. Segue a sessão properties do pom e na
  sequencia o pom inteiro na integra pra vcs verem...
  
  #+BEGIN_SRC xml
  <properties>
    <version.hibernate>5.2.2.Final</version.hibernate>
    <version.hibernate-jpa-2.1-api>1.0.0.Final</version.hibernate-jpa-2.1-api>
  </properties>
  #+END_SRC

  Lembrando que dá pra colocar esses valores diretamente na tag
  version da dependencia, mas o bom é usar boas práticas bem como a prática de mercado que é
  usar o properties porque assim fica mais simpes mudar de versão no
  futuro. 

  Pom, na integra...
  #+INCLUDE:PC2LojaDeInformatica/lojainformatica/pom.xml :src xml
  

  
* Configurar o Hibernate
  A gente configura toda a conexão e demais caractarísitcas de
  funcionamento do hibernate utillizando o arquivo hibernate.cfg.xml
  Vc vai colocar esse arquivo em DIRETORIO_DO_SEU_PROJETO/src/main/resources/hibernate.cfg.xml
  
  Segue o meu Hibernete.cfg.xml que utilizei pra fazer essa aula, 
  Lembrando que vc tem que adequar as configurações pro seu ambiente
  O prof te ajuda...

  #+INCLUDE:./PC2LojaDeInformatica/lojainformatica/src/main/resources/hibernate.cfg.xml :src xml


  O que é é importante ressaltar nesse arquivo hibernate.cfg.xml é o
  seguinte...

  O sessão do arquivo mais importante é o session-factory...
  por isso que depois no código, qdo vc for utilizar o hibernate, vc
  vai ver que vc cria uma session... 
  Bom então faz muito sentido essa sessão do xml chamar session
  factory porque é exatamente a configuração do session que vc vai
  obter pelo código.
  Por enquanto vc precisa entender somente que a session é o acesso ao
  banco mais algumas funcionaldiades importantes do hibernate.

  Esse parte configuraçã a conexão com o banco utilizando aqueles
  mesmos parametros que utilizamos antes quando utilizávamos apenas o
  jdbc puro, sem o hibernate.
  #+BEGIN_SRC xml
      <property name="connection.driver_class">com.mysql.jdbc.Driver</property>
      <property name="connection.url">jdbc:mysql://192.168.33.151/lojainfo?serverTimezone=UTC</property>
      <property name="connection.username">root</property>
      <property name="connection.password">admin123</property>
  #+END_SRC


  #+BEGIN_SRC xml
  <property name="dialect">org.hibernate.dialect.MySQLDialect</property>
  #+END_SRC

  Pra entender essa sessão vc só precisa lembrar que cada banco tem um
  dialeto diferente de sql, então estamos utilizando o dialeto do
  mysql.

  #+BEGIN_SRC xml  
      <!-- Echo all executed SQL to stdout -->
      <property name="show_sql">true</property>
  #+END_SRC

  Esse true avisa hibernate que queremos que ele nos mostre todos os
  sqls que ele contruir pra interagir com o banco de dados.
  
#+BEGIN_SRC xml     
      <!-- Database DDL behavior-->
      <property name="hibernate.hbm2ddl.auto">update</property>
#+END_SRC

Esse "update" significa que queremos que o hibernate mantenha o nosso
banco sempre modificado conforme as alterações que fazemos nas nossas entities.

#+BEGIN_SRC xml
       <!-- 
      <property name="hibernate.hbm2ddl.auto">create-drop</property>
      -->
      <mapping class="br.edu.etec.lojainformatica.model.Cliente" />
      <mapping class="br.edu.etec.lojainformatica.model.Hardware" />
      <mapping class="br.edu.etec.lojainformatica.model.Vendas" />
#+END_SRC

Aqui nós estamos indicando quais são as classes que o hibernate vai
considerar pra construir o banco. Essas classes tem que estar
anotadas.


* Anotação das classes
  
  As classes tem que ter pelo menos duas anotações...
  #+BEGIN_SRC java
  package br.edu.etec.lojainformatica.model;

  import javax.persistence.*;

  @Entity
  public class Cliente {

    @Id @GeneratedValue(strategy=GenerationType.IDENTITY)
	private Integer id_cliente;
	private String nome;
	private String endereco;
	private String fone;
	private String email;

  #+END_SRC

  A anotação @Entity e a anotação @Id.  A entity significa que essa
  classe é uma classe em que suas instancias serão mantidas no banco
  de dados utilizando JPA. 
  A anotação @Id indica qual o campo que serã a chave primária
  A anotação opcional
  @GeneratedValue(strategy=GenerationType.IDENTITY) indica que
  queremos que nossa chave primária deve ser autonumeração.


* Obtendo uma sessão
  Lembra que a gente utilizava uma classe JdbcUtil.java que tinha um
  método estático getConnection o qual retornava um conexão...
  Agora termos uma classe HibernateUtil com um método estático que
  retorna uma sessão do hibernate.
  
  Segue nossa classe pra gente conhecer...
  
  #+INCLUDE:./PC2LojaDeInformatica/lojainformatica/src/main/java/br/edu/etec/lojainformatica/persistence/HibernateUtil.java :src java


* Agora, persistindo uma instancia de cliente
  
  Bom, o padrão DAO a gente já conhecia.

#+BEGIN_SRC java
	public static void main(String[] args) {
		//App app = new App();
		
          
		Cliente c1 = new Cliente();      
                c1.setNome("Huguinho");
                c1.setEndereco("End do Huguinho");
                c1.setFone("1234");       
		
		
		Session session = HibernateUtil.getSessionFactory().openSession();
        
		ClienteHibernateDAO<Cliente> clienteDao = new ClienteHibernateDAO<Cliente>(session);
		clienteDao.beginTransaction();
                clienteDao.persistir(c1);  
                clienteDao.commit();
                clienteDao.closeSession();
                
	}
#+END_SRC


